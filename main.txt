from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime
import logging
from simulator.continuous_production_simulator import create_continuous_simulator
import threading
#from ..simulator.mes_simulator import create_mes_simulator
#from ..database.mes_database import create_mes_database

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# 允许跨域
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# 全局模拟器实例
simulator = create_continuous_simulator(batch_size=10, interval_seconds=5, fault_rate=0.1)

class ProductionPart(BaseModel):
    part_id: str
    type: str
    production_date: str
    status: str
    test_results: str

class ProductionStats(BaseModel):
    total_parts: int
    test_results: str
    total_errors: int
    components: str
    fault_rate: float

class ProductionStatus(BaseModel):
    parts_produced: int
    production_rate: int
    started_at: str
    last_part_at: str

class SimulatorStatus(BaseModel):
    running: bool
    config: Dict[str, Any]
    stats: Dict[str, Any]

@app.on_event("startup")
def startup_event():
    """启动时初始化模拟器"""
    logger.info("Initializing continuous production simulator...")
    simulator.start()

@app.on_event("shutdown")
def shutdown_event():
    """关闭时停止模拟器"""
    logger.info("Stopping continuous production simulator...")
    simulator.stop()

@app.get("/api/production/control/start")
def start_production():
    """启动生产模拟"""
    if not simulator.running:
        simulator.start()
    return {"status": "started", "timestamp": datetime.now().isoformat()}

@app.get("/api/production/control/stop")
def stop_production():
    """停止生产模拟"""
    if simulator.running:
        simulator.stop()
    return {"status": "stopped", "timestamp": datetime.now().isoformat()}

@app.get("/api/production/status", response_model=ProductionStatus)
def get_production_status():
    """获取当前生产状态"""
    status = simulator.get_status()
    return {
        "parts_produced": status["stats"]["total_parts_generated"],
        "production_rate": int(status["stats"]["total_parts_generated"] / (status["runtime_seconds"] / 60) if "runtime_seconds" in status else 0,
        "started_at": status["stats"]["start_time"].isoformat() if status["stats"]["start_time"] else "",
        "last_part_at": status["stats"]["last_batch_time"].isoformat() if status["stats"]["last_batch_time"] else ""
    }

@app.get("/api/production/stats", response_model=ProductionStats)
def get_production_stats():
    """获取生产统计数据"""
    stats = simulator.mes_simulator.data_generator.generate_production_statistics()
    return stats

@app.get("/api/production/recent", response_model=List[ProductionPart])
def get_recent_production(limit: int = 20):
    """获取最近生产数据"""
    return simulator.mes_simulator.get_recent_production(limit)

@app.post("/api/production/simulate")
def simulate_production(count: int = 10000):
    """模拟一次性生产"""
    def run_simulation():
        parts = count // 3  # 转换为main parts数量
        result = simulator.mes_simulator.generate_and_store_production_data(
            num_main_parts=parts,
            sim_fault_rate=0.1
        )
        logger.info(f"Simulated {count} parts: {result}")

    # 在后台线程中运行模拟
    thread = threading.Thread(target=run_simulation)
    thread.start()
    
    return {"message": f"Started simulation of {count} parts"}

@app.get("/api/simulator/status", response_model=SimulatorStatus)
def get_simulator_status():
    """获取模拟器状态"""
    status = simulator.get_status()
    return {
        "running": status["running"],
        "config": status["configuration"],
        "stats": status["statistics"]
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)